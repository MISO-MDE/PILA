/*
 * generated by Xtext 2.10.0
 */
package co.edu.uniandes.serializer;

import co.edu.uniandes.pagos.Adicion;
import co.edu.uniandes.pagos.Application;
import co.edu.uniandes.pagos.CalculationTemplate;
import co.edu.uniandes.pagos.EntityAttribute;
import co.edu.uniandes.pagos.ExpresionLogica;
import co.edu.uniandes.pagos.FormAttribute;
import co.edu.uniandes.pagos.Formula;
import co.edu.uniandes.pagos.InformationTemplate;
import co.edu.uniandes.pagos.Intermediary;
import co.edu.uniandes.pagos.Multiplicacion;
import co.edu.uniandes.pagos.PagosPackage;
import co.edu.uniandes.pagos.Participant;
import co.edu.uniandes.pagos.Provider;
import co.edu.uniandes.pagos.SuperEntity;
import co.edu.uniandes.pagos.SuperEntityAttribute;
import co.edu.uniandes.pagos.TerminalValue;
import co.edu.uniandes.pagos.VariableAttribute;
import co.edu.uniandes.pagos.mathADD;
import co.edu.uniandes.pagos.mathMULT;
import co.edu.uniandes.services.PagosGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PagosSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PagosGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PagosPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PagosPackage.ADICION:
				sequence_Adicion(context, (Adicion) semanticObject); 
				return; 
			case PagosPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case PagosPackage.CALCULATION_TEMPLATE:
				sequence_CalculationTemplate(context, (CalculationTemplate) semanticObject); 
				return; 
			case PagosPackage.ENTITY_ATTRIBUTE:
				sequence_EntityAttribute(context, (EntityAttribute) semanticObject); 
				return; 
			case PagosPackage.EXPRESION_LOGICA:
				sequence_ExpresionLogica(context, (ExpresionLogica) semanticObject); 
				return; 
			case PagosPackage.FORM_ATTRIBUTE:
				sequence_FormAttribute(context, (FormAttribute) semanticObject); 
				return; 
			case PagosPackage.FORMULA:
				sequence_Formula(context, (Formula) semanticObject); 
				return; 
			case PagosPackage.INFORMATION_TEMPLATE:
				sequence_InformationTemplate(context, (InformationTemplate) semanticObject); 
				return; 
			case PagosPackage.INTERMEDIARY:
				sequence_Intermediary(context, (Intermediary) semanticObject); 
				return; 
			case PagosPackage.MULTIPLICACION:
				sequence_Multiplicacion(context, (Multiplicacion) semanticObject); 
				return; 
			case PagosPackage.PARTICIPANT:
				sequence_Participant(context, (Participant) semanticObject); 
				return; 
			case PagosPackage.PROVIDER:
				sequence_Provider(context, (Provider) semanticObject); 
				return; 
			case PagosPackage.SUPER_ENTITY:
				sequence_SuperEntity(context, (SuperEntity) semanticObject); 
				return; 
			case PagosPackage.SUPER_ENTITY_ATTRIBUTE:
				sequence_SuperEntityAttribute(context, (SuperEntityAttribute) semanticObject); 
				return; 
			case PagosPackage.TERMINAL_VALUE:
				sequence_TerminalValue(context, (TerminalValue) semanticObject); 
				return; 
			case PagosPackage.VARIABLE_ATTRIBUTE:
				sequence_VariableAttribute(context, (VariableAttribute) semanticObject); 
				return; 
			case PagosPackage.MATH_ADD:
				sequence_mathADD(context, (mathADD) semanticObject); 
				return; 
			case PagosPackage.MATH_MULT:
				sequence_mathMULT(context, (mathMULT) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Adicion returns Adicion
	 *     Adicion.Adicion_1_0 returns Adicion
	 *     Multiplicacion returns Adicion
	 *     Multiplicacion.Multiplicacion_1_0 returns Adicion
	 *     SigleExp returns Adicion
	 *
	 * Constraint:
	 *     (left=Adicion_Adicion_1_0 operator=mathADD rexp=Multiplicacion)
	 */
	protected void sequence_Adicion(ISerializationContext context, Adicion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.ADICION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.ADICION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.ADICION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.ADICION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.ADICION__REXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.ADICION__REXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdicionAccess().getAdicionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdicionAccess().getOperatorMathADDParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAdicionAccess().getRexpMultiplicacionParserRuleCall_1_2_0(), semanticObject.getRexp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (name=ID intermediary=Intermediary)
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.APPLICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.APPLICATION__NAME));
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.APPLICATION__INTERMEDIARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.APPLICATION__INTERMEDIARY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApplicationAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getApplicationAccess().getIntermediaryIntermediaryParserRuleCall_7_0(), semanticObject.getIntermediary());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CalculationTemplate returns CalculationTemplate
	 *
	 * Constraint:
	 *     (name=ID description=STRING attLists+=VariableAttribute attLists+=VariableAttribute* formula+=Formula)
	 */
	protected void sequence_CalculationTemplate(ISerializationContext context, CalculationTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityAttribute returns EntityAttribute
	 *     CalculationAttribute returns EntityAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TYPE)
	 */
	protected void sequence_EntityAttribute(ISerializationContext context, EntityAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityAttributeAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEntityAttributeAccess().getTypeTYPETerminalRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpresionLogica returns ExpresionLogica
	 *
	 * Constraint:
	 *     (variable+=TerminalValue (logOper+=OPERADORLOGICO (variable2+=TerminalValue | literal+=STRING))+ exp+=ExpresionLogica?)
	 */
	protected void sequence_ExpresionLogica(ISerializationContext context, ExpresionLogica semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormAttribute returns FormAttribute
	 *     CalculationAttribute returns FormAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TYPE exp=Adicion?)
	 */
	protected void sequence_FormAttribute(ISerializationContext context, FormAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Formula
	 *
	 * Constraint:
	 *     (logExp+=ExpresionLogica expression+=Adicion (logExp+=ExpresionLogica? expression+=Adicion)*)
	 */
	protected void sequence_Formula(ISerializationContext context, Formula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InformationTemplate returns InformationTemplate
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         formLists+=FormAttribute 
	 *         formLists+=FormAttribute* 
	 *         (templates+=CalculationTemplate templates+=CalculationTemplate*)? 
	 *         (providers+=Provider providers+=Provider*)?
	 *     )
	 */
	protected void sequence_InformationTemplate(ISerializationContext context, InformationTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Intermediary returns Intermediary
	 *
	 * Constraint:
	 *     (name=ID superentitie+=SuperEntity superentitie+=SuperEntity*)
	 */
	protected void sequence_Intermediary(ISerializationContext context, Intermediary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Adicion returns Multiplicacion
	 *     Adicion.Adicion_1_0 returns Multiplicacion
	 *     Multiplicacion returns Multiplicacion
	 *     Multiplicacion.Multiplicacion_1_0 returns Multiplicacion
	 *     SigleExp returns Multiplicacion
	 *
	 * Constraint:
	 *     (left=Multiplicacion_Multiplicacion_1_0 operator=mathMULT rexp=SigleExp)
	 */
	protected void sequence_Multiplicacion(ISerializationContext context, Multiplicacion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.MULTIPLICACION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.MULTIPLICACION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.MULTIPLICACION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.MULTIPLICACION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.MULTIPLICACION__REXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.MULTIPLICACION__REXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicacionAccess().getMultiplicacionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicacionAccess().getOperatorMathMULTParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMultiplicacionAccess().getRexpSigleExpParserRuleCall_1_2_0(), semanticObject.getRexp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Participant returns Participant
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         attLists+=EntityAttribute 
	 *         attLists+=EntityAttribute* 
	 *         (templatesForm+=InformationTemplate templatesForm+=InformationTemplate*)?
	 *     )
	 */
	protected void sequence_Participant(ISerializationContext context, Participant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Provider returns Provider
	 *
	 * Constraint:
	 *     (name=ID description=STRING attLists+=SuperEntityAttribute attLists+=SuperEntityAttribute*)
	 */
	protected void sequence_Provider(ISerializationContext context, Provider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SuperEntityAttribute returns SuperEntityAttribute
	 *     CalculationAttribute returns SuperEntityAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TYPE)
	 */
	protected void sequence_SuperEntityAttribute(ISerializationContext context, SuperEntityAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.CALCULATION_ATTRIBUTE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSuperEntityAttributeAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSuperEntityAttributeAccess().getTypeTYPETerminalRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SuperEntity returns SuperEntity
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         attLists+=SuperEntityAttribute 
	 *         attLists+=SuperEntityAttribute* 
	 *         participante+=Participant 
	 *         participante+=Participant*
	 *     )
	 */
	protected void sequence_SuperEntity(ISerializationContext context, SuperEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Adicion returns TerminalValue
	 *     Adicion.Adicion_1_0 returns TerminalValue
	 *     Multiplicacion returns TerminalValue
	 *     Multiplicacion.Multiplicacion_1_0 returns TerminalValue
	 *     SigleExp returns TerminalValue
	 *     TerminalValue returns TerminalValue
	 *
	 * Constraint:
	 *     (variable=[CalculationAttribute|ID] | valor=Number)
	 */
	protected void sequence_TerminalValue(ISerializationContext context, TerminalValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableAttribute returns VariableAttribute
	 *     CalculationAttribute returns VariableAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TYPE exp=Adicion?)
	 */
	protected void sequence_VariableAttribute(ISerializationContext context, VariableAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     mathADD returns mathADD
	 *
	 * Constraint:
	 *     operador=ADDOP
	 */
	protected void sequence_mathADD(ISerializationContext context, mathADD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.MATH_ADD__OPERADOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.MATH_ADD__OPERADOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathADDAccess().getOperadorADDOPTerminalRuleCall_1_0(), semanticObject.getOperador());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     mathMULT returns mathMULT
	 *
	 * Constraint:
	 *     operador=MULTOP
	 */
	protected void sequence_mathMULT(ISerializationContext context, mathMULT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PagosPackage.Literals.MATH_MULT__OPERADOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PagosPackage.Literals.MATH_MULT__OPERADOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathMULTAccess().getOperadorMULTOPTerminalRuleCall_1_0(), semanticObject.getOperador());
		feeder.finish();
	}
	
	
}
